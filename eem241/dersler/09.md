# local global değişkenler


```python
def myfunction():
   a = 10
   b = 20
   print("variable a:", a)
   print("variable b:", b)
   return a+b
   
print (myfunction())
```

    variable a: 10
    variable b: 20
    30
    


```python
#global variables
name = 'TutorialsPoint'
marks = 50
def myfunction():
   # accessing inside the function
   print("name:", name)
   print("marks:", marks)
# function call   
myfunction()
```

    name: TutorialsPoint
    marks: 50
    

# File read write


```python
modlar: r,w,a
```


```python
file = open("a.txt", "r")
metin=file.read()
file.close()
```


```python
metin
```




    'abc\ndef'




```python
file = open("example.txt", "w")
file.write("This is an example.")
file.close()
print ("File closed successfully!!")
```


```python
with open("example.txt", "r") as file:
   content = file.read()
   print(content)
```


```python
with open("foo.txt", "w") as file:
   file.write("Hello, World!")
   print ("Content added Successfully!!")
```

# Sınıf


```python
class Kisi:
    def selam(self):
        print("merhaba")

ali = Kisi()
ali.selam()
        
```

    merhaba
    


```python
class Kisi:
    def __init__(self, isim, yas):
        self.isim=isim
        self.yas=yas
        
    def bilgi(self):
        print(f"{self.isim} isimli kisinin yasi. {self.yas}")


    def __str__(self):
        return f"{self.isim} isimli kisinin yasi. {self.yas}"
    
    

ali = Kisi("abc",20)
ali.bilgi()
```

    abc isimli kisinin yasi. 20
    


```python
print(ali)
```

    abc isimli kisinin yasi. 20
    


```python

```


```python
class Ogrenci(Kisi):
    def __init__(self, isim, yas, giris_yili):
        # Kisi sınıfının init metodunu çağırıyoruz
        super().__init__(isim, yas)
        self.giris_yili = giris_yili

    # Bilgi metodunu override ederek öğrenciye özel bilgi ekliyoruz
    def bilgi(self):
        print(f"{self.isim} isimli ogrencinin yasi: {self.yas}, giris yili: {self.giris_yili}")

        
```


```python

```


```python
import math

# Base class for all shapes
class Shape:
    def area(self):
        return 0  # Default area for a generic shape

    def perimeter(self):
        return 0  # Default perimeter for a generic shape

    def __str__(self):
        return "This is a shape."

# Rectangle class inheriting from Shape
class Rectangle(Shape):
    def __init__(self, length, width):
        self.length = length
        self.width = width

    def area(self):
        return self.length * self.width

    def perimeter(self):
        return 2 * (self.length + self.width)

    def __str__(self):
        return f"Rectangle(length={self.length}, width={self.width})"

    # Compare rectangles based on area
    def __eq__(self, other):
        return self.area() == other.area()

    def __lt__(self, other):
        return self.area() < other.area()

# Circle class inheriting from Shape
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * self.radius ** 2

    def perimeter(self):
        return 2 * math.pi * self.radius

    def __str__(self):
        return f"Circle(radius={self.radius:.2f})"

    # Compare circles based on area
    def __eq__(self, other):
        return self.area() == other.area()

    def __lt__(self, other):
        return self.area() < other.area()

# Example Usage
if __name__ == "__main__":
    # Create shapes
    rect1 = Rectangle(5, 3)
    rect2 = Rectangle(6, 2)
    circle1 = Circle(3)
    circle2 = Circle(2)

    # Print shapes
    print(rect1)  # Uses __str__
    print(circle1)

    # Calculate and display area and perimeter
    print(f"Area of {rect1}: {rect1.area()}")
    print(f"Perimeter of {rect1}: {rect1.perimeter()}")
    print(f"Area of {circle1}: {circle1.area():.2f}")
    print(f"Perimeter of {circle1}: {circle1.perimeter():.2f}")

    # Compare shapes
    print("\nComparing Shapes:")
    print(f"Is {rect1} equal to {rect2}? {'Yes' if rect1 == rect2 else 'No'}")
    print(f"Is {circle1} smaller than {circle2}? {'Yes' if circle1 < circle2 else 'No'}")

    # Combine different types
    shapes = [rect1, rect2, circle1, circle2]
    print("\nShapes sorted by area:")
    shapes.sort()  # Sort based on area using __lt__
    for shape in shapes:
        print(f"{shape} with area: {shape.area():.2f}")

```

    Rectangle(length=5, width=3)
    Circle(radius=3.00)
    Area of Rectangle(length=5, width=3): 15
    Perimeter of Rectangle(length=5, width=3): 16
    Area of Circle(radius=3.00): 28.27
    Perimeter of Circle(radius=3.00): 18.85
    
    Comparing Shapes:
    Is Rectangle(length=5, width=3) equal to Rectangle(length=6, width=2)? No
    Is Circle(radius=3.00) smaller than Circle(radius=2.00)? No
    
    Shapes sorted by area:
    Rectangle(length=6, width=2) with area: 12.00
    Circle(radius=2.00) with area: 12.57
    Rectangle(length=5, width=3) with area: 15.00
    Circle(radius=3.00) with area: 28.27
    


```python
import cmath 

class ComplexNumber:
    def __init__(self, value):
        if type(value)==complex:
            self.value = value
        elif type(value)==tuple and len(value)==2:
            r, theta_deg = value
            theta_rad=(theta_deg/180)*cmath.pi
            self.value = cmath.rect(r, theta_rad)
            
        else:
            # print("HATA!")
            raise ValueError("Invalid input: must be a complex number or a (r, theta) tuple")
            

    def kutupsal(self):
        r, theta_rad= cmath.polar(self.value)
        theta_deg=(theta_rad/cmath.pi)*180
        return (r, theta_deg)
    
    def __repr__(self):
        return f"{self.value.real} + j{self.value.imag}"

    def __add__(self, other):
        return ComplexNumber(self.value + other.value)

    def __sub__(self, other):
        return ComplexNumber(self.value - other.value)

    def __mul__(self, other):
        r1, theta1 = self.kutupsal()
        r2, theta2 = other.kutupsal()
        r_result = r1 * r2
        theta_result = theta1 + theta2
        return ComplexNumber((r_result, theta_result))

    def __truediv__(self, other):
        r1, theta1 = self.kutupsal()
        r2, theta2 = other.kutupsal()
        if r2 == 0:
            raise ZeroDivisionError("Cannot divide by zero.")
        r_result = r1 / r2
        theta_result = theta1 - theta2
        return ComplexNumber((r_result, theta_result))

    def __lt__(self, other):
        if abs(self.value) < abs(other.value):
            return True
        return False
    def __abs__(self):
        return abs(self.value)
            
            
        
```


```python
type(1+2j)
```




    complex




```python
a=ComplexNumber(1+2j)
b=ComplexNumber(2+3j)
```


```python
abs(a)
```




    2.23606797749979




```python
a.kutupsal()
```




    (2.23606797749979, 63.43494882292201)




```python
a>b
```




    False




```python
abs(1+2j)
```




    2.23606797749979



